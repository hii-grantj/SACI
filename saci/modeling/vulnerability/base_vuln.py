from dataclasses import dataclass

from saci.modeling.attack import BaseAttackVector, BaseCompEffect
from saci.modeling.device import ComponentID, Device, CyberComponentBase
from saci.modeling.communication import BaseCommunication

from typing import List

@dataclass(frozen=True)
class VulnerabilityEffect:
    """What the presence of a vulnerability means for our modeling of the device."""

    reason: str # Why is this effect present? Oftentimes just a stringified version of the vulnerability.

    def apply_to_device(self, device: Device):
        raise NotImplementedError()

@dataclass(frozen=True)
class AddEdgesEffect(VulnerabilityEffect):
    """An effect that adds more edges to the graph."""

    edges: frozenset[tuple[ComponentID, ComponentID]]

    def apply_to_device(self, device: Device):
        for from_, to_ in self.edges:
            device.component_graph.add_edge(from_, to_, generated=True, generation_reason=self.reason)

@dataclass(frozen=True)
class MakeEntryEffect(VulnerabilityEffect):
    """An effect that marks a node an entry point for path search."""
    nodes: frozenset[ComponentID]

    def apply_to_device(self, device: Device):
        for node in self.nodes:
            # TODO: attach reason somehow
            device.component_graph.nodes[node]["is_entry"] = True

class BaseVulnerability:
    def __init__(self, 
                 component: CyberComponentBase, 
                 _input: BaseCommunication, 
                 output: BaseCommunication, 
                 associated_cwe = None, 
                 attack_ASP = None, 
                 rulefile = None,
                 attack_vectors_exploits =  None):
        self.component = component
        self.input = _input
        self.output = output
        self.associated_cwe = associated_cwe
        self.attack_ASP = attack_ASP 
        self.rulefile = rulefile
        self.attack_vectors_exploits = attack_vectors_exploits

    def exists(self, device: Device) -> bool:
        raise NotImplementedError

    def effects(self, device: Device) -> list[VulnerabilityEffect]:
        """What are all the effects this vulnerability has on our modeling of the device?

        Assumes self.exists(device) returns True.
        """

        return []

    def apply_effects(self, device: Device):
        """Applies all the effects of this vulnerability to the device.

        Assumes self.exists(device) returns True.
        """

        for effect in self.effects(device):
            effect.apply_to_device(device)
